(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2025                                               *)
(*    CEA (Commissariat a l'energie atomique et aux energies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* DO NOT EDIT: this file is generated at build time *)

(* Tactics for failing proofs:
   intros variables ; compute_in_goal ; cvc5 *)

module ValueCodec
  use int.Int
  use int.ComputerDivision
  use frama_c_wp.cint.Cint
  use frama_c_wp.sequence.Seq
  
  function decode_uint8 (s: seq int) : int =
    match s with
    | L.Cons b0 (L.Nil) ->
      b0 * 0x1
    | _ -> 0
    end
    
  function decode_sint8 (s: seq int) : int =
    to_sint8 (decode_uint8 s)
    
  function encode_uint8 (v: int) : seq int =
    (L.Cons (mod v 0x100) L.Nil)
    
  function encode_sint8 (v: int) : seq int =
    encode_uint8 (to_uint8 v)
    
  lemma decode_uint8_encode_uint8:
    forall v: int [decode_uint8 (encode_uint8 v)].
    is_uint8 v -> decode_uint8 (encode_uint8 v) = v
    
  lemma decode_sint8_encode_uint8:
    forall v: int [decode_sint8 (encode_uint8 v)].
    is_uint8 v -> decode_sint8 (encode_uint8 v) = to_sint8 v
    
  lemma decode_uint8_encode_sint8:
    forall v: int [decode_uint8 (encode_sint8 v)].
    is_sint8 v -> decode_uint8 (encode_sint8 v) = to_uint8 v
    
  lemma decode_sint8_encode_sint8:
    forall v: int [decode_sint8 (encode_sint8 v)].
    is_sint8 v -> decode_sint8 (encode_sint8 v) = v
    
  function decode_uint16 (s: seq int) : int =
    match s with
    | L.Cons b0 (L.Cons b1 (L.Nil)) ->
      b0 * 0x1 + b1 * 0x100
    | _ -> 0
    end
    
  function decode_sint16 (s: seq int) : int =
    to_sint16 (decode_uint16 s)
    
  function encode_uint16 (v: int) : seq int =
    (L.Cons (mod v 0x100)
    (L.Cons (mod (div v 0x100) 0x100) L.Nil))
    
  function encode_sint16 (v: int) : seq int =
    encode_uint16 (to_uint16 v)
    
  lemma decode_uint16_encode_uint16:
    forall v: int [decode_uint16 (encode_uint16 v)].
    is_uint16 v -> decode_uint16 (encode_uint16 v) = v
    
  lemma decode_sint16_encode_uint16:
    forall v: int [decode_sint16 (encode_uint16 v)].
    is_uint16 v -> decode_sint16 (encode_uint16 v) = to_sint16 v
    
  lemma decode_uint16_encode_sint16:
    forall v: int [decode_uint16 (encode_sint16 v)].
    is_sint16 v -> decode_uint16 (encode_sint16 v) = to_uint16 v
    
  lemma decode_sint16_encode_sint16:
    forall v: int [decode_sint16 (encode_sint16 v)].
    is_sint16 v -> decode_sint16 (encode_sint16 v) = v
    
  function decode_uint32 (s: seq int) : int =
    match s with
    | L.Cons b0 (L.Cons b1 (L.Cons b2 (L.Cons b3 (L.Nil)))) ->
      b0 * 0x1 + b1 * 0x100 + b2 * 0x10000 + b3 * 0x1000000
    | _ -> 0
    end
    
  function decode_sint32 (s: seq int) : int =
    to_sint32 (decode_uint32 s)
    
  function encode_uint32 (v: int) : seq int =
    (L.Cons (mod v 0x100)
    (L.Cons (mod (div v 0x100) 0x100)
    (L.Cons (mod (div v 0x10000) 0x100)
    (L.Cons (mod (div v 0x1000000) 0x100) L.Nil))))
    
  function encode_sint32 (v: int) : seq int =
    encode_uint32 (to_uint32 v)
    
  lemma decode_uint32_encode_uint32:
    forall v: int [decode_uint32 (encode_uint32 v)].
    is_uint32 v -> decode_uint32 (encode_uint32 v) = v
    
  lemma decode_sint32_encode_uint32:
    forall v: int [decode_sint32 (encode_uint32 v)].
    is_uint32 v -> decode_sint32 (encode_uint32 v) = to_sint32 v
    
  lemma decode_uint32_encode_sint32:
    forall v: int [decode_uint32 (encode_sint32 v)].
    is_sint32 v -> decode_uint32 (encode_sint32 v) = to_uint32 v
    
  lemma decode_sint32_encode_sint32:
    forall v: int [decode_sint32 (encode_sint32 v)].
    is_sint32 v -> decode_sint32 (encode_sint32 v) = v
    
  function decode_uint64 (s: seq int) : int =
    match s with
    | L.Cons b0 (L.Cons b1 (L.Cons b2 (L.Cons b3 (L.Cons b4 (L.Cons b5 (L.Cons b6 (L.Cons b7 (L.Nil)))))))) ->
      b0 * 0x1 + b1 * 0x100 + b2 * 0x10000 + b3 * 0x1000000 + b4 * 0x100000000 + b5 * 0x10000000000 + b6 * 0x1000000000000 + b7 * 0x100000000000000
    | _ -> 0
    end
    
  function decode_sint64 (s: seq int) : int =
    to_sint64 (decode_uint64 s)
    
  function encode_uint64 (v: int) : seq int =
    (L.Cons (mod v 0x100)
    (L.Cons (mod (div v 0x100) 0x100)
    (L.Cons (mod (div v 0x10000) 0x100)
    (L.Cons (mod (div v 0x1000000) 0x100)
    (L.Cons (mod (div v 0x100000000) 0x100)
    (L.Cons (mod (div v 0x10000000000) 0x100)
    (L.Cons (mod (div v 0x1000000000000) 0x100)
    (L.Cons (mod (div v 0x100000000000000) 0x100) L.Nil))))))))
    
  function encode_sint64 (v: int) : seq int =
    encode_uint64 (to_uint64 v)
    
  lemma decode_uint64_encode_uint64:
    forall v: int [decode_uint64 (encode_uint64 v)].
    is_uint64 v -> decode_uint64 (encode_uint64 v) = v
    
  lemma decode_sint64_encode_uint64:
    forall v: int [decode_sint64 (encode_uint64 v)].
    is_uint64 v -> decode_sint64 (encode_uint64 v) = to_sint64 v
    
  lemma decode_uint64_encode_sint64:
    forall v: int [decode_uint64 (encode_sint64 v)].
    is_sint64 v -> decode_uint64 (encode_sint64 v) = to_uint64 v
    
  lemma decode_sint64_encode_sint64:
    forall v: int [decode_sint64 (encode_sint64 v)].
    is_sint64 v -> decode_sint64 (encode_sint64 v) = v
    
  
end

module InitCodec
  use bool.Bool
  use frama_c_wp.sequence.Seq
  
  function decode_init8 (s: seq bool) : bool =
    match s with
    | L.Cons b0 (L.Nil) ->
      b0
    | _ -> false
    end
    
  function encode_init8 (v: bool) : seq bool =
    create v 1
    
  lemma decode_init8_encode_init8:
    forall v: bool [decode_init8 (encode_init8 v)].
    decode_init8 (encode_init8 v) = v
    
  function decode_init16 (s: seq bool) : bool =
    match s with
    | L.Cons b0 (L.Cons b1 (L.Nil)) ->
      b0 && b1
    | _ -> false
    end
    
  function encode_init16 (v: bool) : seq bool =
    create v 2
    
  lemma decode_init16_encode_init16:
    forall v: bool [decode_init16 (encode_init16 v)].
    decode_init16 (encode_init16 v) = v
    
  function decode_init32 (s: seq bool) : bool =
    match s with
    | L.Cons b0 (L.Cons b1 (L.Cons b2 (L.Cons b3 (L.Nil)))) ->
      b0 && b1 && b2 && b3
    | _ -> false
    end
    
  function encode_init32 (v: bool) : seq bool =
    create v 4
    
  lemma decode_init32_encode_init32:
    forall v: bool [decode_init32 (encode_init32 v)].
    decode_init32 (encode_init32 v) = v
    
  function decode_init64 (s: seq bool) : bool =
    match s with
    | L.Cons b0 (L.Cons b1 (L.Cons b2 (L.Cons b3 (L.Cons b4 (L.Cons b5 (L.Cons b6 (L.Cons b7 (L.Nil)))))))) ->
      b0 && b1 && b2 && b3 && b4 && b5 && b6 && b7
    | _ -> false
    end
    
  function encode_init64 (v: bool) : seq bool =
    create v 8
    
  lemma decode_init64_encode_init64:
    forall v: bool [decode_init64 (encode_init64 v)].
    decode_init64 (encode_init64 v) = v
    
  
end

module Offset
  use int.Int
  type offset = int

  predicate sepoffset (po: offset) (lp: int) (qo: offset) (lq: int) =
    qo + lq <= po \/ po + lp <= qo

end

module RWBytes
  use int.Int
  use map.Map as M
  use frama_c_wp.sequence.Seq as S
  use Offset
  
  type seq   'a = S.seq 'a
  type block 'a = M.map int 'a

  function bwrite_seq (b:block 'a) (o: int) (s: seq 'a) : block 'a =
    match s with
    | S.L.Nil -> b
    | S.L.Cons h tl -> M.(set (bwrite_seq b (o+1) tl) o h)
    end

  predicate beq_blocks (b1 b2: block 'a) (o: int) (l: int) =
    forall i: int. o <= i < o + l -> M.(get b1 i) = M.(get b2 i)

  function bread_8bits (b: block 'a) (o: int) : seq 'a =
    (S.L.Cons M.(b[o  ]) S.L.Nil)
    
  function bread_16bits (b: block 'a) (o: int) : seq 'a =
    (S.L.Cons M.(b[o  ])
    (S.L.Cons M.(b[o+1]) S.L.Nil))
    
  function bread_32bits (b: block 'a) (o: int) : seq 'a =
    (S.L.Cons M.(b[o  ])
    (S.L.Cons M.(b[o+1])
    (S.L.Cons M.(b[o+2])
    (S.L.Cons M.(b[o+3]) S.L.Nil))))
    
  function bread_64bits (b: block 'a) (o: int) : seq 'a =
    (S.L.Cons M.(b[o  ])
    (S.L.Cons M.(b[o+1])
    (S.L.Cons M.(b[o+2])
    (S.L.Cons M.(b[o+3])
    (S.L.Cons M.(b[o+4])
    (S.L.Cons M.(b[o+5])
    (S.L.Cons M.(b[o+6])
    (S.L.Cons M.(b[o+7]) S.L.Nil))))))))
    
  function bwrite_8bits (b: block 'a) (o: int) (s: seq 'a) : block 'a =
    match s with
    | S.L.Cons b0 (_) ->
      M.(set b o b0)
    | _ -> b
    end
    
  function bwrite_16bits (b: block 'a) (o: int) (s: seq 'a) : block 'a =
    match s with
    | S.L.Cons b0 (S.L.Cons b1 (_)) ->
      M.(set (set b (o+1) b1) o b0)
    | _ -> b
    end
    
  function bwrite_32bits (b: block 'a) (o: int) (s: seq 'a) : block 'a =
    match s with
    | S.L.Cons b0 (S.L.Cons b1 (S.L.Cons b2 (S.L.Cons b3 (_)))) ->
      M.(set (set (set (set b (o+3) b3) (o+2) b2) (o+1) b1) o b0)
    | _ -> b
    end
    
  function bwrite_64bits (b: block 'a) (o: int) (s: seq 'a) : block 'a =
    match s with
    | S.L.Cons b0 (S.L.Cons b1 (S.L.Cons b2 (S.L.Cons b3 (S.L.Cons b4 (S.L.Cons b5 (S.L.Cons b6 (S.L.Cons b7 (_)))))))) ->
      M.(set (set (set (set (set (set (set (set b (o+7) b7) (o+6) b6) (o+5) b5) (o+4) b4) (o+3) b3) (o+2) b2) (o+1) b1) o b0)
    | _ -> b
    end
    
  lemma bread_8bits_bwrite_8bits_eq:
    forall b: block 'a, o: int, s: seq 'a [bread_8bits (bwrite_8bits b o s) o].
    S.length s = 1 ->
      bread_8bits (bwrite_8bits b o s) o = s
  
  let rec lemma bread_8bits_bwrite_seq_sep (b: block 'a)(or ow: int)(s: seq 'a)
    requires { sepoffset ow (S.length s) or 1 }
    ensures  { bread_8bits (bwrite_seq b ow s) or = bread_8bits b or }
    = match s with
      | S.L.Nil -> ()
      | S.L.Cons _ tl -> bread_8bits_bwrite_seq_sep b or (ow + 1) tl
      end
  
  lemma bread_8bits_bwrite_8bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_8bits (bwrite_8bits b ow s) or].
    sepoffset ow 1 or 1 ->
      bread_8bits (bwrite_8bits b ow s) or = bread_8bits b or
  
  lemma bread_8bits_bwrite_16bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_8bits (bwrite_16bits b ow s) or].
    sepoffset ow 2 or 1 ->
      bread_8bits (bwrite_16bits b ow s) or = bread_8bits b or
  
  lemma bread_8bits_bwrite_32bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_8bits (bwrite_32bits b ow s) or].
    sepoffset ow 4 or 1 ->
      bread_8bits (bwrite_32bits b ow s) or = bread_8bits b or
  
  lemma bread_8bits_bwrite_64bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_8bits (bwrite_64bits b ow s) or].
    sepoffset ow 8 or 1 ->
      bread_8bits (bwrite_64bits b ow s) or = bread_8bits b or
  
  lemma bread_16bits_bwrite_16bits_eq:
    forall b: block 'a, o: int, s: seq 'a [bread_16bits (bwrite_16bits b o s) o].
    S.length s = 2 ->
      bread_16bits (bwrite_16bits b o s) o = s
  
  let rec lemma bread_16bits_bwrite_seq_sep (b: block 'a)(or ow: int)(s: seq 'a)
    requires { sepoffset ow (S.length s) or 2 }
    ensures  { bread_16bits (bwrite_seq b ow s) or = bread_16bits b or }
    = match s with
      | S.L.Nil -> ()
      | S.L.Cons _ tl -> bread_16bits_bwrite_seq_sep b or (ow + 1) tl
      end
  
  lemma bread_16bits_bwrite_8bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_16bits (bwrite_8bits b ow s) or].
    sepoffset ow 1 or 2 ->
      bread_16bits (bwrite_8bits b ow s) or = bread_16bits b or
  
  lemma bread_16bits_bwrite_16bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_16bits (bwrite_16bits b ow s) or].
    sepoffset ow 2 or 2 ->
      bread_16bits (bwrite_16bits b ow s) or = bread_16bits b or
  
  lemma bread_16bits_bwrite_32bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_16bits (bwrite_32bits b ow s) or].
    sepoffset ow 4 or 2 ->
      bread_16bits (bwrite_32bits b ow s) or = bread_16bits b or
  
  lemma bread_16bits_bwrite_64bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_16bits (bwrite_64bits b ow s) or].
    sepoffset ow 8 or 2 ->
      bread_16bits (bwrite_64bits b ow s) or = bread_16bits b or
  
  lemma bread_32bits_bwrite_32bits_eq:
    forall b: block 'a, o: int, s: seq 'a [bread_32bits (bwrite_32bits b o s) o].
    S.length s = 4 ->
      bread_32bits (bwrite_32bits b o s) o = s
  
  let rec lemma bread_32bits_bwrite_seq_sep (b: block 'a)(or ow: int)(s: seq 'a)
    requires { sepoffset ow (S.length s) or 4 }
    ensures  { bread_32bits (bwrite_seq b ow s) or = bread_32bits b or }
    = match s with
      | S.L.Nil -> ()
      | S.L.Cons _ tl -> bread_32bits_bwrite_seq_sep b or (ow + 1) tl
      end
  
  lemma bread_32bits_bwrite_8bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_32bits (bwrite_8bits b ow s) or].
    sepoffset ow 1 or 4 ->
      bread_32bits (bwrite_8bits b ow s) or = bread_32bits b or
  
  lemma bread_32bits_bwrite_16bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_32bits (bwrite_16bits b ow s) or].
    sepoffset ow 2 or 4 ->
      bread_32bits (bwrite_16bits b ow s) or = bread_32bits b or
  
  lemma bread_32bits_bwrite_32bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_32bits (bwrite_32bits b ow s) or].
    sepoffset ow 4 or 4 ->
      bread_32bits (bwrite_32bits b ow s) or = bread_32bits b or
  
  lemma bread_32bits_bwrite_64bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_32bits (bwrite_64bits b ow s) or].
    sepoffset ow 8 or 4 ->
      bread_32bits (bwrite_64bits b ow s) or = bread_32bits b or
  
  lemma bread_64bits_bwrite_64bits_eq:
    forall b: block 'a, o: int, s: seq 'a [bread_64bits (bwrite_64bits b o s) o].
    S.length s = 8 ->
      bread_64bits (bwrite_64bits b o s) o = s
  
  let rec lemma bread_64bits_bwrite_seq_sep (b: block 'a)(or ow: int)(s: seq 'a)
    requires { sepoffset ow (S.length s) or 8 }
    ensures  { bread_64bits (bwrite_seq b ow s) or = bread_64bits b or }
    = match s with
      | S.L.Nil -> ()
      | S.L.Cons _ tl -> bread_64bits_bwrite_seq_sep b or (ow + 1) tl
      end
  
  lemma bread_64bits_bwrite_8bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_64bits (bwrite_8bits b ow s) or].
    sepoffset ow 1 or 8 ->
      bread_64bits (bwrite_8bits b ow s) or = bread_64bits b or
  
  lemma bread_64bits_bwrite_16bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_64bits (bwrite_16bits b ow s) or].
    sepoffset ow 2 or 8 ->
      bread_64bits (bwrite_16bits b ow s) or = bread_64bits b or
  
  lemma bread_64bits_bwrite_32bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_64bits (bwrite_32bits b ow s) or].
    sepoffset ow 4 or 8 ->
      bread_64bits (bwrite_32bits b ow s) or = bread_64bits b or
  
  lemma bread_64bits_bwrite_64bits_sep:
    forall b: block 'a, or ow: int, s: seq 'a [bread_64bits (bwrite_64bits b ow s) or].
    sepoffset ow 8 or 8 ->
      bread_64bits (bwrite_64bits b ow s) or = bread_64bits b or
  
  
end

module ValueBlockRW
  use int.Int
  use frama_c_wp.cint.Cint
  use ValueCodec
  use Offset
  use RWBytes
  
  type vblock = block int
  
  function bread_uint8 (b: vblock) (o: int) : int =
    decode_uint8 (bread_8bits b o)
    
  function bread_uint16 (b: vblock) (o: int) : int =
    decode_uint16 (bread_16bits b o)
    
  function bread_uint32 (b: vblock) (o: int) : int =
    decode_uint32 (bread_32bits b o)
    
  function bread_uint64 (b: vblock) (o: int) : int =
    decode_uint64 (bread_64bits b o)
    
  function bread_sint8 (b: vblock) (o: int) : int =
    decode_sint8 (bread_8bits b o)
    
  function bread_sint16 (b: vblock) (o: int) : int =
    decode_sint16 (bread_16bits b o)
    
  function bread_sint32 (b: vblock) (o: int) : int =
    decode_sint32 (bread_32bits b o)
    
  function bread_sint64 (b: vblock) (o: int) : int =
    decode_sint64 (bread_64bits b o)
    
  function bwrite_uint8 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_8bits b o (encode_uint8 v)
    
  function bwrite_uint16 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_16bits b o (encode_uint16 v)
    
  function bwrite_uint32 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_32bits b o (encode_uint32 v)
    
  function bwrite_uint64 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_64bits b o (encode_uint64 v)
    
  function bwrite_sint8 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_8bits b o (encode_sint8 v)
    
  function bwrite_sint16 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_16bits b o (encode_sint16 v)
    
  function bwrite_sint32 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_32bits b o (encode_sint32 v)
    
  function bwrite_sint64 (b: vblock) (o: int) (v: int) : vblock =
    bwrite_64bits b o (encode_sint64 v)
    
  lemma bread_uint8_bwrite_uint8_eq:
    forall b: vblock, o: int, v: int [bread_uint8 (bwrite_uint8 b o v) o].
    is_uint8 v ->
      bread_uint8 (bwrite_uint8 b o v) o = v
    
  lemma bread_uint8_bwrite_sint8_eq:
    forall b: vblock, o: int, v: int [bread_uint8 (bwrite_sint8 b o v) o].
    is_sint8 v ->
      bread_uint8 (bwrite_sint8 b o v) o = to_uint8 v
    
  lemma bread_uint8_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_uint8 (bwrite_seq b ho u) or].
    sepoffset or 1 ho (Seq.length u) ->
      bread_uint8 (bwrite_seq b ho u) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 1 ->
      bread_uint8 (bwrite_uint8 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 1 ->
      bread_uint8 (bwrite_uint16 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 1 ->
      bread_uint8 (bwrite_uint32 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 1 ->
      bread_uint8 (bwrite_uint64 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 1 ->
      bread_uint8 (bwrite_sint8 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 1 ->
      bread_uint8 (bwrite_sint16 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 1 ->
      bread_uint8 (bwrite_sint32 b ow v) or = bread_uint8 b or
    
  lemma bread_uint8_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint8 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 1 ->
      bread_uint8 (bwrite_sint64 b ow v) or = bread_uint8 b or
    
  lemma bread_uint16_bwrite_uint16_eq:
    forall b: vblock, o: int, v: int [bread_uint16 (bwrite_uint16 b o v) o].
    is_uint16 v ->
      bread_uint16 (bwrite_uint16 b o v) o = v
    
  lemma bread_uint16_bwrite_sint16_eq:
    forall b: vblock, o: int, v: int [bread_uint16 (bwrite_sint16 b o v) o].
    is_sint16 v ->
      bread_uint16 (bwrite_sint16 b o v) o = to_uint16 v
    
  lemma bread_uint16_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_uint16 (bwrite_seq b ho u) or].
    sepoffset or 2 ho (Seq.length u) ->
      bread_uint16 (bwrite_seq b ho u) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 2 ->
      bread_uint16 (bwrite_uint8 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 2 ->
      bread_uint16 (bwrite_uint16 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 2 ->
      bread_uint16 (bwrite_uint32 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 2 ->
      bread_uint16 (bwrite_uint64 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 2 ->
      bread_uint16 (bwrite_sint8 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 2 ->
      bread_uint16 (bwrite_sint16 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 2 ->
      bread_uint16 (bwrite_sint32 b ow v) or = bread_uint16 b or
    
  lemma bread_uint16_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint16 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 2 ->
      bread_uint16 (bwrite_sint64 b ow v) or = bread_uint16 b or
    
  lemma bread_uint32_bwrite_uint32_eq:
    forall b: vblock, o: int, v: int [bread_uint32 (bwrite_uint32 b o v) o].
    is_uint32 v ->
      bread_uint32 (bwrite_uint32 b o v) o = v
    
  lemma bread_uint32_bwrite_sint32_eq:
    forall b: vblock, o: int, v: int [bread_uint32 (bwrite_sint32 b o v) o].
    is_sint32 v ->
      bread_uint32 (bwrite_sint32 b o v) o = to_uint32 v
    
  lemma bread_uint32_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_uint32 (bwrite_seq b ho u) or].
    sepoffset or 4 ho (Seq.length u) ->
      bread_uint32 (bwrite_seq b ho u) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 4 ->
      bread_uint32 (bwrite_uint8 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 4 ->
      bread_uint32 (bwrite_uint16 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 4 ->
      bread_uint32 (bwrite_uint32 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 4 ->
      bread_uint32 (bwrite_uint64 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 4 ->
      bread_uint32 (bwrite_sint8 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 4 ->
      bread_uint32 (bwrite_sint16 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 4 ->
      bread_uint32 (bwrite_sint32 b ow v) or = bread_uint32 b or
    
  lemma bread_uint32_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint32 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 4 ->
      bread_uint32 (bwrite_sint64 b ow v) or = bread_uint32 b or
    
  lemma bread_uint64_bwrite_uint64_eq:
    forall b: vblock, o: int, v: int [bread_uint64 (bwrite_uint64 b o v) o].
    is_uint64 v ->
      bread_uint64 (bwrite_uint64 b o v) o = v
    
  lemma bread_uint64_bwrite_sint64_eq:
    forall b: vblock, o: int, v: int [bread_uint64 (bwrite_sint64 b o v) o].
    is_sint64 v ->
      bread_uint64 (bwrite_sint64 b o v) o = to_uint64 v
    
  lemma bread_uint64_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_uint64 (bwrite_seq b ho u) or].
    sepoffset or 8 ho (Seq.length u) ->
      bread_uint64 (bwrite_seq b ho u) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 8 ->
      bread_uint64 (bwrite_uint8 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 8 ->
      bread_uint64 (bwrite_uint16 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 8 ->
      bread_uint64 (bwrite_uint32 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 8 ->
      bread_uint64 (bwrite_uint64 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 8 ->
      bread_uint64 (bwrite_sint8 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 8 ->
      bread_uint64 (bwrite_sint16 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 8 ->
      bread_uint64 (bwrite_sint32 b ow v) or = bread_uint64 b or
    
  lemma bread_uint64_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_uint64 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 8 ->
      bread_uint64 (bwrite_sint64 b ow v) or = bread_uint64 b or
    
  lemma bread_sint8_bwrite_sint8_eq:
    forall b: vblock, o: int, v: int [bread_sint8 (bwrite_sint8 b o v) o].
    is_sint8 v ->
      bread_sint8 (bwrite_sint8 b o v) o = v
    
  lemma bread_sint8_bwrite_uint8_eq:
    forall b: vblock, o: int, v: int [bread_sint8 (bwrite_uint8 b o v) o].
    is_uint8 v ->
      bread_sint8 (bwrite_uint8 b o v) o = to_sint8 v
    
  lemma bread_sint8_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_sint8 (bwrite_seq b ho u) or].
    sepoffset or 1 ho (Seq.length u) ->
      bread_sint8 (bwrite_seq b ho u) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 1 ->
      bread_sint8 (bwrite_uint8 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 1 ->
      bread_sint8 (bwrite_uint16 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 1 ->
      bread_sint8 (bwrite_uint32 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 1 ->
      bread_sint8 (bwrite_uint64 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 1 ->
      bread_sint8 (bwrite_sint8 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 1 ->
      bread_sint8 (bwrite_sint16 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 1 ->
      bread_sint8 (bwrite_sint32 b ow v) or = bread_sint8 b or
    
  lemma bread_sint8_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint8 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 1 ->
      bread_sint8 (bwrite_sint64 b ow v) or = bread_sint8 b or
    
  lemma bread_sint16_bwrite_sint16_eq:
    forall b: vblock, o: int, v: int [bread_sint16 (bwrite_sint16 b o v) o].
    is_sint16 v ->
      bread_sint16 (bwrite_sint16 b o v) o = v
    
  lemma bread_sint16_bwrite_uint16_eq:
    forall b: vblock, o: int, v: int [bread_sint16 (bwrite_uint16 b o v) o].
    is_uint16 v ->
      bread_sint16 (bwrite_uint16 b o v) o = to_sint16 v
    
  lemma bread_sint16_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_sint16 (bwrite_seq b ho u) or].
    sepoffset or 2 ho (Seq.length u) ->
      bread_sint16 (bwrite_seq b ho u) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 2 ->
      bread_sint16 (bwrite_uint8 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 2 ->
      bread_sint16 (bwrite_uint16 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 2 ->
      bread_sint16 (bwrite_uint32 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 2 ->
      bread_sint16 (bwrite_uint64 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 2 ->
      bread_sint16 (bwrite_sint8 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 2 ->
      bread_sint16 (bwrite_sint16 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 2 ->
      bread_sint16 (bwrite_sint32 b ow v) or = bread_sint16 b or
    
  lemma bread_sint16_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint16 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 2 ->
      bread_sint16 (bwrite_sint64 b ow v) or = bread_sint16 b or
    
  lemma bread_sint32_bwrite_sint32_eq:
    forall b: vblock, o: int, v: int [bread_sint32 (bwrite_sint32 b o v) o].
    is_sint32 v ->
      bread_sint32 (bwrite_sint32 b o v) o = v
    
  lemma bread_sint32_bwrite_uint32_eq:
    forall b: vblock, o: int, v: int [bread_sint32 (bwrite_uint32 b o v) o].
    is_uint32 v ->
      bread_sint32 (bwrite_uint32 b o v) o = to_sint32 v
    
  lemma bread_sint32_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_sint32 (bwrite_seq b ho u) or].
    sepoffset or 4 ho (Seq.length u) ->
      bread_sint32 (bwrite_seq b ho u) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 4 ->
      bread_sint32 (bwrite_uint8 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 4 ->
      bread_sint32 (bwrite_uint16 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 4 ->
      bread_sint32 (bwrite_uint32 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 4 ->
      bread_sint32 (bwrite_uint64 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 4 ->
      bread_sint32 (bwrite_sint8 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 4 ->
      bread_sint32 (bwrite_sint16 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 4 ->
      bread_sint32 (bwrite_sint32 b ow v) or = bread_sint32 b or
    
  lemma bread_sint32_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint32 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 4 ->
      bread_sint32 (bwrite_sint64 b ow v) or = bread_sint32 b or
    
  lemma bread_sint64_bwrite_sint64_eq:
    forall b: vblock, o: int, v: int [bread_sint64 (bwrite_sint64 b o v) o].
    is_sint64 v ->
      bread_sint64 (bwrite_sint64 b o v) o = v
    
  lemma bread_sint64_bwrite_uint64_eq:
    forall b: vblock, o: int, v: int [bread_sint64 (bwrite_uint64 b o v) o].
    is_uint64 v ->
      bread_sint64 (bwrite_uint64 b o v) o = to_sint64 v
    
  lemma bread_sint64_bcopy_sep:
    forall b: vblock, u: S.seq int, or ho: int [bread_sint64 (bwrite_seq b ho u) or].
    sepoffset or 8 ho (Seq.length u) ->
      bread_sint64 (bwrite_seq b ho u) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_uint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_uint8 b ow v) or].
    sepoffset ow 1 or 8 ->
      bread_sint64 (bwrite_uint8 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_uint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_uint16 b ow v) or].
    sepoffset ow 2 or 8 ->
      bread_sint64 (bwrite_uint16 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_uint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_uint32 b ow v) or].
    sepoffset ow 4 or 8 ->
      bread_sint64 (bwrite_uint32 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_uint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_uint64 b ow v) or].
    sepoffset ow 8 or 8 ->
      bread_sint64 (bwrite_uint64 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_sint8_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_sint8 b ow v) or].
    sepoffset ow 1 or 8 ->
      bread_sint64 (bwrite_sint8 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_sint16_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_sint16 b ow v) or].
    sepoffset ow 2 or 8 ->
      bread_sint64 (bwrite_sint16 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_sint32_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_sint32 b ow v) or].
    sepoffset ow 4 or 8 ->
      bread_sint64 (bwrite_sint32 b ow v) or = bread_sint64 b or
    
  lemma bread_sint64_bwrite_sint64_sep:
    forall b: vblock, or ow: int, v: int [bread_sint64 (bwrite_sint64 b ow v) or].
    sepoffset ow 8 or 8 ->
      bread_sint64 (bwrite_sint64 b ow v) or = bread_sint64 b or
    
  
end

module InitBlockRW
  use bool.Bool
  use int.Int
  use InitCodec
  use Offset
  use RWBytes
  
  type iblock = block bool
  
  predicate is_init_range(b: iblock) (o: int) (size: int) =
    forall i: int. o <= i < o + size -> M.get b i = True
  
  function bread_init8 (b: iblock) (o: int) : bool =
    decode_init8 (bread_8bits b o)
    
  function bread_init16 (b: iblock) (o: int) : bool =
    decode_init16 (bread_16bits b o)
    
  function bread_init32 (b: iblock) (o: int) : bool =
    decode_init32 (bread_32bits b o)
    
  function bread_init64 (b: iblock) (o: int) : bool =
    decode_init64 (bread_64bits b o)
    
  function bwrite_init8 (b: iblock) (o: int) (init: bool) : iblock =
    bwrite_8bits b o (encode_init8 init)
    
  function bwrite_init16 (b: iblock) (o: int) (init: bool) : iblock =
    bwrite_16bits b o (encode_init16 init)
    
  function bwrite_init32 (b: iblock) (o: int) (init: bool) : iblock =
    bwrite_32bits b o (encode_init32 init)
    
  function bwrite_init64 (b: iblock) (o: int) (init: bool) : iblock =
    bwrite_64bits b o (encode_init64 init)
    
  lemma bread_init8_bwrite_init8_eq:
    forall b: iblock, o: int, init: bool [bread_init8 (bwrite_init8 b o init) o].
    bread_init8 (bwrite_init8 b o init) o = init
    
  lemma bread_init8_bcopy_sep:
    forall b: iblock, u: S.seq bool, or ho: int [bread_init8 (bwrite_seq b ho u) or].
    sepoffset or 1 ho (Seq.length u) ->
      bread_init8 (bwrite_seq b ho u) or = bread_init8 b or
    
  lemma bread_init8_bwrite_init8_sep:
    forall b: iblock, or ow: int, init: bool [bread_init8 (bwrite_init8 b ow init) or].
    sepoffset ow 1 or 1 ->
      bread_init8 (bwrite_init8 b ow init) or = bread_init8 b or
    
  lemma bread_init8_bwrite_init16_sep:
    forall b: iblock, or ow: int, init: bool [bread_init8 (bwrite_init16 b ow init) or].
    sepoffset ow 2 or 1 ->
      bread_init8 (bwrite_init16 b ow init) or = bread_init8 b or
    
  lemma bread_init8_bwrite_init32_sep:
    forall b: iblock, or ow: int, init: bool [bread_init8 (bwrite_init32 b ow init) or].
    sepoffset ow 4 or 1 ->
      bread_init8 (bwrite_init32 b ow init) or = bread_init8 b or
    
  lemma bread_init8_bwrite_init64_sep:
    forall b: iblock, or ow: int, init: bool [bread_init8 (bwrite_init64 b ow init) or].
    sepoffset ow 8 or 1 ->
      bread_init8 (bwrite_init64 b ow init) or = bread_init8 b or
    
  lemma bread_init16_bwrite_init16_eq:
    forall b: iblock, o: int, init: bool [bread_init16 (bwrite_init16 b o init) o].
    bread_init16 (bwrite_init16 b o init) o = init
    
  lemma bread_init16_bcopy_sep:
    forall b: iblock, u: S.seq bool, or ho: int [bread_init16 (bwrite_seq b ho u) or].
    sepoffset or 2 ho (Seq.length u) ->
      bread_init16 (bwrite_seq b ho u) or = bread_init16 b or
    
  lemma bread_init16_bwrite_init8_sep:
    forall b: iblock, or ow: int, init: bool [bread_init16 (bwrite_init8 b ow init) or].
    sepoffset ow 1 or 2 ->
      bread_init16 (bwrite_init8 b ow init) or = bread_init16 b or
    
  lemma bread_init16_bwrite_init16_sep:
    forall b: iblock, or ow: int, init: bool [bread_init16 (bwrite_init16 b ow init) or].
    sepoffset ow 2 or 2 ->
      bread_init16 (bwrite_init16 b ow init) or = bread_init16 b or
    
  lemma bread_init16_bwrite_init32_sep:
    forall b: iblock, or ow: int, init: bool [bread_init16 (bwrite_init32 b ow init) or].
    sepoffset ow 4 or 2 ->
      bread_init16 (bwrite_init32 b ow init) or = bread_init16 b or
    
  lemma bread_init16_bwrite_init64_sep:
    forall b: iblock, or ow: int, init: bool [bread_init16 (bwrite_init64 b ow init) or].
    sepoffset ow 8 or 2 ->
      bread_init16 (bwrite_init64 b ow init) or = bread_init16 b or
    
  lemma bread_init32_bwrite_init32_eq:
    forall b: iblock, o: int, init: bool [bread_init32 (bwrite_init32 b o init) o].
    bread_init32 (bwrite_init32 b o init) o = init
    
  lemma bread_init32_bcopy_sep:
    forall b: iblock, u: S.seq bool, or ho: int [bread_init32 (bwrite_seq b ho u) or].
    sepoffset or 4 ho (Seq.length u) ->
      bread_init32 (bwrite_seq b ho u) or = bread_init32 b or
    
  lemma bread_init32_bwrite_init8_sep:
    forall b: iblock, or ow: int, init: bool [bread_init32 (bwrite_init8 b ow init) or].
    sepoffset ow 1 or 4 ->
      bread_init32 (bwrite_init8 b ow init) or = bread_init32 b or
    
  lemma bread_init32_bwrite_init16_sep:
    forall b: iblock, or ow: int, init: bool [bread_init32 (bwrite_init16 b ow init) or].
    sepoffset ow 2 or 4 ->
      bread_init32 (bwrite_init16 b ow init) or = bread_init32 b or
    
  lemma bread_init32_bwrite_init32_sep:
    forall b: iblock, or ow: int, init: bool [bread_init32 (bwrite_init32 b ow init) or].
    sepoffset ow 4 or 4 ->
      bread_init32 (bwrite_init32 b ow init) or = bread_init32 b or
    
  lemma bread_init32_bwrite_init64_sep:
    forall b: iblock, or ow: int, init: bool [bread_init32 (bwrite_init64 b ow init) or].
    sepoffset ow 8 or 4 ->
      bread_init32 (bwrite_init64 b ow init) or = bread_init32 b or
    
  lemma bread_init64_bwrite_init64_eq:
    forall b: iblock, o: int, init: bool [bread_init64 (bwrite_init64 b o init) o].
    bread_init64 (bwrite_init64 b o init) o = init
    
  lemma bread_init64_bcopy_sep:
    forall b: iblock, u: S.seq bool, or ho: int [bread_init64 (bwrite_seq b ho u) or].
    sepoffset or 8 ho (Seq.length u) ->
      bread_init64 (bwrite_seq b ho u) or = bread_init64 b or
    
  lemma bread_init64_bwrite_init8_sep:
    forall b: iblock, or ow: int, init: bool [bread_init64 (bwrite_init8 b ow init) or].
    sepoffset ow 1 or 8 ->
      bread_init64 (bwrite_init8 b ow init) or = bread_init64 b or
    
  lemma bread_init64_bwrite_init16_sep:
    forall b: iblock, or ow: int, init: bool [bread_init64 (bwrite_init16 b ow init) or].
    sepoffset ow 2 or 8 ->
      bread_init64 (bwrite_init16 b ow init) or = bread_init64 b or
    
  lemma bread_init64_bwrite_init32_sep:
    forall b: iblock, or ow: int, init: bool [bread_init64 (bwrite_init32 b ow init) or].
    sepoffset ow 4 or 8 ->
      bread_init64 (bwrite_init32 b ow init) or = bread_init64 b or
    
  lemma bread_init64_bwrite_init64_sep:
    forall b: iblock, or ow: int, init: bool [bread_init64 (bwrite_init64 b ow init) or].
    sepoffset ow 8 or 8 ->
      bread_init64 (bwrite_init64 b ow init) or = bread_init64 b or
    
  
end

module MemBytes
  use int.Int
  use map.Map
  use frama_c_wp.cint.Cint
  use frama_c_wp.memaddr.MemAddr
  use frama_c_wp.sequence.Seq as S
  use RWBytes
  use ValueBlockRW as VB
  use InitBlockRW as IB
  
  type memory = map int (VB.vblock)
  type init   = map int (IB.iblock)

  (* override memory cinits for MemBytes memory *)
  predicate cinits (init)

  function raw_get (m: map int (map int 'a)) (a: addr) : 'a =
    get (get m a.base) a.offset

  function raw_set (m: map int (map int 'a)) (a: addr) (v: 'a) : map int (map int 'a) =
    set m a.base (set (get m a.base) a.offset v)

  let rec function to_seq (a: map int 'a) (b e: int) : S.seq 'a
    ensures { e - b >= 0 -> S.length result = e - b }
    ensures { forall i: int. b <= i < e -> S.(result[i - b]) = get a i }
    variant { e - b }
  = if e <= b then S.L.Nil else S.L.Cons (get a b) (to_seq a (b+1) e)

  function init_seq (s: int) : S.seq bool =
    S.create True s

  function memcpy (mtgt msrc: map int (block 'a)) (ptgt psrc: addr) (size: int): map int (block 'a) =
    set mtgt ptgt.base (bwrite_seq (get msrc psrc.base) ptgt.offset (to_seq msrc[psrc.base] psrc.offset size))

  predicate eqmem (m1 m2: map int (block 'a)) (a: addr) (size: int) =
    beq_blocks (get m1 a.base) (get m2 a.base) (a.offset) size

  predicate is_init_range (i: init) (a: addr) (size: int) =
    IB.is_init_range (get i a.base) a.offset size

  function set_init_range (cur: init) (a: addr) (size: int) : init =
    set cur a.base (bwrite_seq (get cur a.base) a.offset (init_seq size))

  function read_uint8 (m: memory) (a: addr) : int =
    VB.bread_uint8 m[a.base] a.offset
    
  function read_uint16 (m: memory) (a: addr) : int =
    VB.bread_uint16 m[a.base] a.offset
    
  function read_uint32 (m: memory) (a: addr) : int =
    VB.bread_uint32 m[a.base] a.offset
    
  function read_uint64 (m: memory) (a: addr) : int =
    VB.bread_uint64 m[a.base] a.offset
    
  function read_sint8 (m: memory) (a: addr) : int =
    VB.bread_sint8 m[a.base] a.offset
    
  function read_sint16 (m: memory) (a: addr) : int =
    VB.bread_sint16 m[a.base] a.offset
    
  function read_sint32 (m: memory) (a: addr) : int =
    VB.bread_sint32 m[a.base] a.offset
    
  function read_sint64 (m: memory) (a: addr) : int =
    VB.bread_sint64 m[a.base] a.offset
    
  function write_uint8 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_uint8 m [a.base] a.offset v)
    
  function write_uint16 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_uint16 m [a.base] a.offset v)
    
  function write_uint32 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_uint32 m [a.base] a.offset v)
    
  function write_uint64 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_uint64 m [a.base] a.offset v)
    
  function write_sint8 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_sint8 m [a.base] a.offset v)
    
  function write_sint16 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_sint16 m [a.base] a.offset v)
    
  function write_sint32 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_sint32 m [a.base] a.offset v)
    
  function write_sint64 (m: memory) (a: addr) (v: int) : memory =
    set m a.base (VB.bwrite_sint64 m [a.base] a.offset v)
    
  lemma read_uint8_write_uint8_eq:
    forall m: memory, a: addr, v: int [read_uint8 (write_uint8 m a v) a].
    is_uint8 v ->
      read_uint8 (write_uint8 m a v) a = v
    
  lemma read_uint8_write_sint8_eq:
    forall m: memory, a: addr, v: int [read_uint8 (write_sint8 m a v) a].
    is_sint8 v ->
      read_uint8 (write_sint8 m a v) a = to_uint8 v
    
  lemma read_uint8_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_uint8 (memcpy mw mc aw ac size) ar].
    separated ar 1 aw size ->
      read_uint8 (memcpy mw mc aw ac size) ar = read_uint8 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint8 nb ar.offset = VB.bread_uint8 ob ar.offset
    
  lemma read_uint8_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_uint8 m aw v) ar].
    separated aw 1 ar 1 ->
      read_uint8 (write_uint8 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_uint16 m aw v) ar].
    separated aw 2 ar 1 ->
      read_uint8 (write_uint16 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_uint32 m aw v) ar].
    separated aw 4 ar 1 ->
      read_uint8 (write_uint32 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_uint64 m aw v) ar].
    separated aw 8 ar 1 ->
      read_uint8 (write_uint64 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_sint8 m aw v) ar].
    separated aw 1 ar 1 ->
      read_uint8 (write_sint8 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_sint16 m aw v) ar].
    separated aw 2 ar 1 ->
      read_uint8 (write_sint16 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_sint32 m aw v) ar].
    separated aw 4 ar 1 ->
      read_uint8 (write_sint32 m aw v) ar = read_uint8 m ar
    
  lemma read_uint8_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint8 (write_sint64 m aw v) ar].
    separated aw 8 ar 1 ->
      read_uint8 (write_sint64 m aw v) ar = read_uint8 m ar
    
  lemma read_uint16_write_uint16_eq:
    forall m: memory, a: addr, v: int [read_uint16 (write_uint16 m a v) a].
    is_uint16 v ->
      read_uint16 (write_uint16 m a v) a = v
    
  lemma read_uint16_write_sint16_eq:
    forall m: memory, a: addr, v: int [read_uint16 (write_sint16 m a v) a].
    is_sint16 v ->
      read_uint16 (write_sint16 m a v) a = to_uint16 v
    
  lemma read_uint16_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_uint16 (memcpy mw mc aw ac size) ar].
    separated ar 2 aw size ->
      read_uint16 (memcpy mw mc aw ac size) ar = read_uint16 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint16 nb ar.offset = VB.bread_uint16 ob ar.offset
    
  lemma read_uint16_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_uint8 m aw v) ar].
    separated aw 1 ar 2 ->
      read_uint16 (write_uint8 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_uint16 m aw v) ar].
    separated aw 2 ar 2 ->
      read_uint16 (write_uint16 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_uint32 m aw v) ar].
    separated aw 4 ar 2 ->
      read_uint16 (write_uint32 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_uint64 m aw v) ar].
    separated aw 8 ar 2 ->
      read_uint16 (write_uint64 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_sint8 m aw v) ar].
    separated aw 1 ar 2 ->
      read_uint16 (write_sint8 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_sint16 m aw v) ar].
    separated aw 2 ar 2 ->
      read_uint16 (write_sint16 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_sint32 m aw v) ar].
    separated aw 4 ar 2 ->
      read_uint16 (write_sint32 m aw v) ar = read_uint16 m ar
    
  lemma read_uint16_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint16 (write_sint64 m aw v) ar].
    separated aw 8 ar 2 ->
      read_uint16 (write_sint64 m aw v) ar = read_uint16 m ar
    
  lemma read_uint32_write_uint32_eq:
    forall m: memory, a: addr, v: int [read_uint32 (write_uint32 m a v) a].
    is_uint32 v ->
      read_uint32 (write_uint32 m a v) a = v
    
  lemma read_uint32_write_sint32_eq:
    forall m: memory, a: addr, v: int [read_uint32 (write_sint32 m a v) a].
    is_sint32 v ->
      read_uint32 (write_sint32 m a v) a = to_uint32 v
    
  lemma read_uint32_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_uint32 (memcpy mw mc aw ac size) ar].
    separated ar 4 aw size ->
      read_uint32 (memcpy mw mc aw ac size) ar = read_uint32 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint32 nb ar.offset = VB.bread_uint32 ob ar.offset
    
  lemma read_uint32_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_uint8 m aw v) ar].
    separated aw 1 ar 4 ->
      read_uint32 (write_uint8 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_uint16 m aw v) ar].
    separated aw 2 ar 4 ->
      read_uint32 (write_uint16 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_uint32 m aw v) ar].
    separated aw 4 ar 4 ->
      read_uint32 (write_uint32 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_uint64 m aw v) ar].
    separated aw 8 ar 4 ->
      read_uint32 (write_uint64 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_sint8 m aw v) ar].
    separated aw 1 ar 4 ->
      read_uint32 (write_sint8 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_sint16 m aw v) ar].
    separated aw 2 ar 4 ->
      read_uint32 (write_sint16 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_sint32 m aw v) ar].
    separated aw 4 ar 4 ->
      read_uint32 (write_sint32 m aw v) ar = read_uint32 m ar
    
  lemma read_uint32_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint32 (write_sint64 m aw v) ar].
    separated aw 8 ar 4 ->
      read_uint32 (write_sint64 m aw v) ar = read_uint32 m ar
    
  lemma read_uint64_write_uint64_eq:
    forall m: memory, a: addr, v: int [read_uint64 (write_uint64 m a v) a].
    is_uint64 v ->
      read_uint64 (write_uint64 m a v) a = v
    
  lemma read_uint64_write_sint64_eq:
    forall m: memory, a: addr, v: int [read_uint64 (write_sint64 m a v) a].
    is_sint64 v ->
      read_uint64 (write_sint64 m a v) a = to_uint64 v
    
  lemma read_uint64_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_uint64 (memcpy mw mc aw ac size) ar].
    separated ar 8 aw size ->
      read_uint64 (memcpy mw mc aw ac size) ar = read_uint64 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint64 nb ar.offset = VB.bread_uint64 ob ar.offset
    
  lemma read_uint64_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_uint8 m aw v) ar].
    separated aw 1 ar 8 ->
      read_uint64 (write_uint8 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_uint16 m aw v) ar].
    separated aw 2 ar 8 ->
      read_uint64 (write_uint16 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_uint32 m aw v) ar].
    separated aw 4 ar 8 ->
      read_uint64 (write_uint32 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_uint64 m aw v) ar].
    separated aw 8 ar 8 ->
      read_uint64 (write_uint64 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_sint8 m aw v) ar].
    separated aw 1 ar 8 ->
      read_uint64 (write_sint8 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_sint16 m aw v) ar].
    separated aw 2 ar 8 ->
      read_uint64 (write_sint16 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_sint32 m aw v) ar].
    separated aw 4 ar 8 ->
      read_uint64 (write_sint32 m aw v) ar = read_uint64 m ar
    
  lemma read_uint64_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_uint64 (write_sint64 m aw v) ar].
    separated aw 8 ar 8 ->
      read_uint64 (write_sint64 m aw v) ar = read_uint64 m ar
    
  lemma read_sint8_write_sint8_eq:
    forall m: memory, a: addr, v: int [read_sint8 (write_sint8 m a v) a].
    is_sint8 v ->
      read_sint8 (write_sint8 m a v) a = v
    
  lemma read_sint8_write_uint8_eq:
    forall m: memory, a: addr, v: int [read_sint8 (write_uint8 m a v) a].
    is_uint8 v ->
      read_sint8 (write_uint8 m a v) a = to_sint8 v
    
  lemma read_sint8_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_sint8 (memcpy mw mc aw ac size) ar].
    separated ar 1 aw size ->
      read_sint8 (memcpy mw mc aw ac size) ar = read_sint8 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint8 nb ar.offset = VB.bread_uint8 ob ar.offset
    
  lemma read_sint8_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_uint8 m aw v) ar].
    separated aw 1 ar 1 ->
      read_sint8 (write_uint8 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_uint16 m aw v) ar].
    separated aw 2 ar 1 ->
      read_sint8 (write_uint16 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_uint32 m aw v) ar].
    separated aw 4 ar 1 ->
      read_sint8 (write_uint32 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_uint64 m aw v) ar].
    separated aw 8 ar 1 ->
      read_sint8 (write_uint64 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_sint8 m aw v) ar].
    separated aw 1 ar 1 ->
      read_sint8 (write_sint8 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_sint16 m aw v) ar].
    separated aw 2 ar 1 ->
      read_sint8 (write_sint16 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_sint32 m aw v) ar].
    separated aw 4 ar 1 ->
      read_sint8 (write_sint32 m aw v) ar = read_sint8 m ar
    
  lemma read_sint8_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint8 (write_sint64 m aw v) ar].
    separated aw 8 ar 1 ->
      read_sint8 (write_sint64 m aw v) ar = read_sint8 m ar
    
  lemma read_sint16_write_sint16_eq:
    forall m: memory, a: addr, v: int [read_sint16 (write_sint16 m a v) a].
    is_sint16 v ->
      read_sint16 (write_sint16 m a v) a = v
    
  lemma read_sint16_write_uint16_eq:
    forall m: memory, a: addr, v: int [read_sint16 (write_uint16 m a v) a].
    is_uint16 v ->
      read_sint16 (write_uint16 m a v) a = to_sint16 v
    
  lemma read_sint16_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_sint16 (memcpy mw mc aw ac size) ar].
    separated ar 2 aw size ->
      read_sint16 (memcpy mw mc aw ac size) ar = read_sint16 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint16 nb ar.offset = VB.bread_uint16 ob ar.offset
    
  lemma read_sint16_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_uint8 m aw v) ar].
    separated aw 1 ar 2 ->
      read_sint16 (write_uint8 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_uint16 m aw v) ar].
    separated aw 2 ar 2 ->
      read_sint16 (write_uint16 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_uint32 m aw v) ar].
    separated aw 4 ar 2 ->
      read_sint16 (write_uint32 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_uint64 m aw v) ar].
    separated aw 8 ar 2 ->
      read_sint16 (write_uint64 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_sint8 m aw v) ar].
    separated aw 1 ar 2 ->
      read_sint16 (write_sint8 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_sint16 m aw v) ar].
    separated aw 2 ar 2 ->
      read_sint16 (write_sint16 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_sint32 m aw v) ar].
    separated aw 4 ar 2 ->
      read_sint16 (write_sint32 m aw v) ar = read_sint16 m ar
    
  lemma read_sint16_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint16 (write_sint64 m aw v) ar].
    separated aw 8 ar 2 ->
      read_sint16 (write_sint64 m aw v) ar = read_sint16 m ar
    
  lemma read_sint32_write_sint32_eq:
    forall m: memory, a: addr, v: int [read_sint32 (write_sint32 m a v) a].
    is_sint32 v ->
      read_sint32 (write_sint32 m a v) a = v
    
  lemma read_sint32_write_uint32_eq:
    forall m: memory, a: addr, v: int [read_sint32 (write_uint32 m a v) a].
    is_uint32 v ->
      read_sint32 (write_uint32 m a v) a = to_sint32 v
    
  lemma read_sint32_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_sint32 (memcpy mw mc aw ac size) ar].
    separated ar 4 aw size ->
      read_sint32 (memcpy mw mc aw ac size) ar = read_sint32 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint32 nb ar.offset = VB.bread_uint32 ob ar.offset
    
  lemma read_sint32_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_uint8 m aw v) ar].
    separated aw 1 ar 4 ->
      read_sint32 (write_uint8 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_uint16 m aw v) ar].
    separated aw 2 ar 4 ->
      read_sint32 (write_uint16 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_uint32 m aw v) ar].
    separated aw 4 ar 4 ->
      read_sint32 (write_uint32 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_uint64 m aw v) ar].
    separated aw 8 ar 4 ->
      read_sint32 (write_uint64 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_sint8 m aw v) ar].
    separated aw 1 ar 4 ->
      read_sint32 (write_sint8 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_sint16 m aw v) ar].
    separated aw 2 ar 4 ->
      read_sint32 (write_sint16 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_sint32 m aw v) ar].
    separated aw 4 ar 4 ->
      read_sint32 (write_sint32 m aw v) ar = read_sint32 m ar
    
  lemma read_sint32_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint32 (write_sint64 m aw v) ar].
    separated aw 8 ar 4 ->
      read_sint32 (write_sint64 m aw v) ar = read_sint32 m ar
    
  lemma read_sint64_write_sint64_eq:
    forall m: memory, a: addr, v: int [read_sint64 (write_sint64 m a v) a].
    is_sint64 v ->
      read_sint64 (write_sint64 m a v) a = v
    
  lemma read_sint64_write_uint64_eq:
    forall m: memory, a: addr, v: int [read_sint64 (write_uint64 m a v) a].
    is_uint64 v ->
      read_sint64 (write_uint64 m a v) a = to_sint64 v
    
  lemma read_sint64_copy_sep:
    forall mw mc: memory, size: int, ar aw ac: addr [read_sint64 (memcpy mw mc aw ac size) ar].
    separated ar 8 aw size ->
      read_sint64 (memcpy mw mc aw ac size) ar = read_sint64 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> VB.bread_uint64 nb ar.offset = VB.bread_uint64 ob ar.offset
    
  lemma read_sint64_write_uint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_uint8 m aw v) ar].
    separated aw 1 ar 8 ->
      read_sint64 (write_uint8 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_uint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_uint16 m aw v) ar].
    separated aw 2 ar 8 ->
      read_sint64 (write_uint16 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_uint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_uint32 m aw v) ar].
    separated aw 4 ar 8 ->
      read_sint64 (write_uint32 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_uint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_uint64 m aw v) ar].
    separated aw 8 ar 8 ->
      read_sint64 (write_uint64 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_sint8_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_sint8 m aw v) ar].
    separated aw 1 ar 8 ->
      read_sint64 (write_sint8 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_sint16_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_sint16 m aw v) ar].
    separated aw 2 ar 8 ->
      read_sint64 (write_sint16 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_sint32_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_sint32 m aw v) ar].
    separated aw 4 ar 8 ->
      read_sint64 (write_sint32 m aw v) ar = read_sint64 m ar
    
  lemma read_sint64_write_sint64_sep:
    forall m: memory, ar aw: addr, v: int [read_sint64 (write_sint64 m aw v) ar].
    separated aw 8 ar 8 ->
      read_sint64 (write_sint64 m aw v) ar = read_sint64 m ar
    
  function read_init8 (m: init) (a: addr) : bool =
    IB.bread_init8 m[a.base] a.offset
    
  function read_init16 (m: init) (a: addr) : bool =
    IB.bread_init16 m[a.base] a.offset
    
  function read_init32 (m: init) (a: addr) : bool =
    IB.bread_init32 m[a.base] a.offset
    
  function read_init64 (m: init) (a: addr) : bool =
    IB.bread_init64 m[a.base] a.offset
    
  function write_init8 (m: init) (a: addr) (i: bool) : init =
    set m a.base (IB.bwrite_init8 m [a.base] a.offset i)
    
  function write_init16 (m: init) (a: addr) (i: bool) : init =
    set m a.base (IB.bwrite_init16 m [a.base] a.offset i)
    
  function write_init32 (m: init) (a: addr) (i: bool) : init =
    set m a.base (IB.bwrite_init32 m [a.base] a.offset i)
    
  function write_init64 (m: init) (a: addr) (i: bool) : init =
    set m a.base (IB.bwrite_init64 m [a.base] a.offset i)
    
  lemma read_init8_write_init8_eq:
    forall m: init, a: addr, i: bool [read_init8 (write_init8 m a i) a].
    read_init8 (write_init8 m a i) a = i
    
  lemma read_init8_copy_sep:
    forall mw mc: init, size: int, ar aw ac: addr [read_init8 (memcpy mw mc aw ac size) ar].
    separated ar 1 aw size ->
      read_init8 (memcpy mw mc aw ac size) ar = read_init8 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> IB.bread_init8 nb ar.offset = IB.bread_init8 ob ar.offset
    
  lemma read_init8_write_init8_sep:
    forall m: init, ar aw: addr, i: bool [read_init8 (write_init8 m aw i) ar].
    separated aw 1 ar 1 ->
      read_init8 (write_init8 m aw i) ar = read_init8 m ar
    
  lemma read_init8_write_init16_sep:
    forall m: init, ar aw: addr, i: bool [read_init8 (write_init16 m aw i) ar].
    separated aw 2 ar 1 ->
      read_init8 (write_init16 m aw i) ar = read_init8 m ar
    
  lemma read_init8_write_init32_sep:
    forall m: init, ar aw: addr, i: bool [read_init8 (write_init32 m aw i) ar].
    separated aw 4 ar 1 ->
      read_init8 (write_init32 m aw i) ar = read_init8 m ar
    
  lemma read_init8_write_init64_sep:
    forall m: init, ar aw: addr, i: bool [read_init8 (write_init64 m aw i) ar].
    separated aw 8 ar 1 ->
      read_init8 (write_init64 m aw i) ar = read_init8 m ar
    
  lemma read_init16_write_init16_eq:
    forall m: init, a: addr, i: bool [read_init16 (write_init16 m a i) a].
    read_init16 (write_init16 m a i) a = i
    
  lemma read_init16_copy_sep:
    forall mw mc: init, size: int, ar aw ac: addr [read_init16 (memcpy mw mc aw ac size) ar].
    separated ar 2 aw size ->
      read_init16 (memcpy mw mc aw ac size) ar = read_init16 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> IB.bread_init16 nb ar.offset = IB.bread_init16 ob ar.offset
    
  lemma read_init16_write_init8_sep:
    forall m: init, ar aw: addr, i: bool [read_init16 (write_init8 m aw i) ar].
    separated aw 1 ar 2 ->
      read_init16 (write_init8 m aw i) ar = read_init16 m ar
    
  lemma read_init16_write_init16_sep:
    forall m: init, ar aw: addr, i: bool [read_init16 (write_init16 m aw i) ar].
    separated aw 2 ar 2 ->
      read_init16 (write_init16 m aw i) ar = read_init16 m ar
    
  lemma read_init16_write_init32_sep:
    forall m: init, ar aw: addr, i: bool [read_init16 (write_init32 m aw i) ar].
    separated aw 4 ar 2 ->
      read_init16 (write_init32 m aw i) ar = read_init16 m ar
    
  lemma read_init16_write_init64_sep:
    forall m: init, ar aw: addr, i: bool [read_init16 (write_init64 m aw i) ar].
    separated aw 8 ar 2 ->
      read_init16 (write_init64 m aw i) ar = read_init16 m ar
    
  lemma read_init32_write_init32_eq:
    forall m: init, a: addr, i: bool [read_init32 (write_init32 m a i) a].
    read_init32 (write_init32 m a i) a = i
    
  lemma read_init32_copy_sep:
    forall mw mc: init, size: int, ar aw ac: addr [read_init32 (memcpy mw mc aw ac size) ar].
    separated ar 4 aw size ->
      read_init32 (memcpy mw mc aw ac size) ar = read_init32 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> IB.bread_init32 nb ar.offset = IB.bread_init32 ob ar.offset
    
  lemma read_init32_write_init8_sep:
    forall m: init, ar aw: addr, i: bool [read_init32 (write_init8 m aw i) ar].
    separated aw 1 ar 4 ->
      read_init32 (write_init8 m aw i) ar = read_init32 m ar
    
  lemma read_init32_write_init16_sep:
    forall m: init, ar aw: addr, i: bool [read_init32 (write_init16 m aw i) ar].
    separated aw 2 ar 4 ->
      read_init32 (write_init16 m aw i) ar = read_init32 m ar
    
  lemma read_init32_write_init32_sep:
    forall m: init, ar aw: addr, i: bool [read_init32 (write_init32 m aw i) ar].
    separated aw 4 ar 4 ->
      read_init32 (write_init32 m aw i) ar = read_init32 m ar
    
  lemma read_init32_write_init64_sep:
    forall m: init, ar aw: addr, i: bool [read_init32 (write_init64 m aw i) ar].
    separated aw 8 ar 4 ->
      read_init32 (write_init64 m aw i) ar = read_init32 m ar
    
  lemma read_init64_write_init64_eq:
    forall m: init, a: addr, i: bool [read_init64 (write_init64 m a i) a].
    read_init64 (write_init64 m a i) a = i
    
  lemma read_init64_copy_sep:
    forall mw mc: init, size: int, ar aw ac: addr [read_init64 (memcpy mw mc aw ac size) ar].
    separated ar 8 aw size ->
      read_init64 (memcpy mw mc aw ac size) ar = read_init64 mw ar
    by
      let ob = mw[aw.base] in
      let nb = bwrite_seq ob aw.offset (to_seq mc[ac.base] ac.offset size) in
      aw.base = ar.base -> IB.bread_init64 nb ar.offset = IB.bread_init64 ob ar.offset
    
  lemma read_init64_write_init8_sep:
    forall m: init, ar aw: addr, i: bool [read_init64 (write_init8 m aw i) ar].
    separated aw 1 ar 8 ->
      read_init64 (write_init8 m aw i) ar = read_init64 m ar
    
  lemma read_init64_write_init16_sep:
    forall m: init, ar aw: addr, i: bool [read_init64 (write_init16 m aw i) ar].
    separated aw 2 ar 8 ->
      read_init64 (write_init16 m aw i) ar = read_init64 m ar
    
  lemma read_init64_write_init32_sep:
    forall m: init, ar aw: addr, i: bool [read_init64 (write_init32 m aw i) ar].
    separated aw 4 ar 8 ->
      read_init64 (write_init32 m aw i) ar = read_init64 m ar
    
  lemma read_init64_write_init64_sep:
    forall m: init, ar aw: addr, i: bool [read_init64 (write_init64 m aw i) ar].
    separated aw 8 ar 8 ->
      read_init64 (write_init64 m aw i) ar = read_init64 m ar
    
  predicate sconst (memory)
  
  predicate bytes(m: memory) =
    forall a: addr. 0 <= raw_get m a <= 255

end
