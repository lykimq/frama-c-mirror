# frama-c -wp [...]
[kernel] Parsing unfold_assigns.i (no preprocessing)
[wp] Running WP plugin...
[kernel:annot:missing-spec] unfold_assigns.i:92: Warning: 
  Neither code nor explicit exits and terminates for function f_assigns_with_array,
   generating default clauses. See -generated-spec-* options for more info
[kernel:annot:missing-spec] unfold_assigns.i:17: Warning: 
  Neither code nor explicit exits and terminates for function f,
   generating default clauses. See -generated-spec-* options for more info
[kernel:annot:missing-spec] unfold_assigns.i:20: Warning: 
  Neither code nor explicit exits and terminates for function g,
   generating default clauses. See -generated-spec-* options for more info
[kernel:annot:missing-spec] unfold_assigns.i:73: Warning: 
  Neither code nor explicit exits and terminates for function f_assigns_range,
   generating default clauses. See -generated-spec-* options for more info
[kernel:annot:missing-spec] unfold_assigns.i:108: Warning: 
  Neither code nor explicit exits and terminates for function f_assigns_range_with_array,
   generating default clauses. See -generated-spec-* options for more info
[wp] [Valid] Goal ASSIGN_NO_UNFOLD_KO_exits (Cfg) (Unreachable)
[wp] [Valid] Goal ASSIGN_NO_UNFOLD_KO_terminates (Cfg) (Trivial)
[wp] Warning: Missing RTE guards
[wp] [Valid] Goal ASSIGN_NO_UNFOLD_OK_exits (Cfg) (Unreachable)
[wp] [Valid] Goal ASSIGN_NO_UNFOLD_OK_terminates (Cfg) (Trivial)
------------------------------------------------------------
  Function ASSIGN_NO_UNFOLD_KO
------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 66) in 'ASSIGN_NO_UNFOLD_KO':
Effect at line 69
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function ASSIGN_NO_UNFOLD_OK
------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 60) in 'ASSIGN_NO_UNFOLD_OK':
Effect at line 63
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function NESTED_ARRAY_STATIC
------------------------------------------------------------

Goal Termination-condition (generated) in 'NESTED_ARRAY_STATIC':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'NESTED_ARRAY_STATIC':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 95) in 'NESTED_ARRAY_STATIC':
Call Effect at line 97
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 95) in 'NESTED_ARRAY_STATIC':
Call Effect at line 97
Assume {
  (* Heap *)
  Type: (region(s.base) <= 0) /\ linked(Malloc_0).
  (* Goal *)
  When: !invalid(Malloc_0, s, 4).
}
Prove: false.

------------------------------------------------------------
------------------------------------------------------------
  Function NESTED_ARRAY_VARS
------------------------------------------------------------

Goal Termination-condition (generated) in 'NESTED_ARRAY_VARS':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'NESTED_ARRAY_VARS':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 102) in 'NESTED_ARRAY_VARS':
Call Effect at line 104
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 102) in 'NESTED_ARRAY_VARS':
Call Effect at line 104
Let a = shiftfield_F2_With_array_t(s).
Let a_1 = shift_sint32(a, 1).
Assume {
  Type: is_uint32(n).
  (* Heap *)
  Type: (region(s.base) <= 0) /\ linked(Malloc_0).
  (* Goal *)
  When: !invalid(Malloc_0, s, 4).
  (* Pre-condition *)
  Have: 3 <= n.
}
Prove: included(s, 4, a_1, n) \/ included(a, 3, a_1, n).

------------------------------------------------------------
------------------------------------------------------------
  Function NO_UNFOLD_KO
------------------------------------------------------------

Goal Termination-condition (generated) in 'NO_UNFOLD_KO':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'NO_UNFOLD_KO':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 37) in 'NO_UNFOLD_KO':
Call Effect at line 39
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 37) in 'NO_UNFOLD_KO':
Call Effect at line 39
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function NO_UNFOLD_OK_1
------------------------------------------------------------

Goal Termination-condition (generated) in 'NO_UNFOLD_OK_1':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'NO_UNFOLD_OK_1':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 22) in 'NO_UNFOLD_OK_1':
Call Effect at line 24
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 22) in 'NO_UNFOLD_OK_1':
Call Effect at line 24
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function NO_UNFOLD_OK_2
------------------------------------------------------------

Goal Termination-condition (generated) in 'NO_UNFOLD_OK_2':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'NO_UNFOLD_OK_2':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 27) in 'NO_UNFOLD_OK_2':
Call Effect at line 29
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 27) in 'NO_UNFOLD_OK_2':
Call Effect at line 29
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function NO_UNFOLD_OK_3
------------------------------------------------------------

Goal Termination-condition (generated) in 'NO_UNFOLD_OK_3':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'NO_UNFOLD_OK_3':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 32) in 'NO_UNFOLD_OK_3':
Call Effect at line 34
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 32) in 'NO_UNFOLD_OK_3':
Call Effect at line 34
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function PARTIAL_ASSIGNS_STATIC
------------------------------------------------------------

Goal Termination-condition (generated) in 'PARTIAL_ASSIGNS_STATIC':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'PARTIAL_ASSIGNS_STATIC':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 75) in 'PARTIAL_ASSIGNS_STATIC':
Call Effect at line 77
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 75) in 'PARTIAL_ASSIGNS_STATIC':
Call Effect at line 77
Assume {
  (* Heap *)
  Type: (region(p.base) <= 0) /\ linked(Malloc_0).
  (* Goal *)
  When: (0 <= i) /\ (i <= 4) /\ (!invalid(Malloc_0, shift_sint32(p, 0), 5)).
}
Prove: (i = 0) \/ (i = 4) \/ ((0 < i) /\ (i <= 3)).

------------------------------------------------------------
------------------------------------------------------------
  Function PARTIAL_ASSIGNS_VARS
------------------------------------------------------------

Goal Termination-condition (generated) in 'PARTIAL_ASSIGNS_VARS':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'PARTIAL_ASSIGNS_VARS':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 81) in 'PARTIAL_ASSIGNS_VARS':
Call Effect at line 83
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 81) in 'PARTIAL_ASSIGNS_VARS':
Call Effect at line 83
Let a = shift_sint32(p, 0).
Let x = 1 + n.
Let a_1 = shift_sint32(p, 1).
Let x_1 = n - 1.
Assume {
  Have: 0 <= n.
  Type: is_uint32(n).
  (* Heap *)
  Type: (region(p.base) <= 0) /\ linked(Malloc_0).
  (* Goal *)
  When: (0 <= i) /\ (i <= n) /\ (!invalid(Malloc_0, a, x)).
  (* Pre-condition *)
  Have: 5 <= n.
}
Prove: (i = 0) \/ (n = i) \/ (n <= 0) \/ included(a, x, a_1, x_1) \/
    included(a, x, shift_sint32(p, n), 1) \/
    included(shift_sint32(p, i), 1, a_1, x_1).

------------------------------------------------------------
------------------------------------------------------------
  Function RANGE_NESTED_ARRAY_STATIC
------------------------------------------------------------

Goal Termination-condition (generated) in 'RANGE_NESTED_ARRAY_STATIC':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'RANGE_NESTED_ARRAY_STATIC':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 111) in 'RANGE_NESTED_ARRAY_STATIC':
Call Effect at line 116
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 111) in 'RANGE_NESTED_ARRAY_STATIC':
Call Effect at line 116
Assume {
  (* Heap *)
  Type: (region(s.base) <= 0) /\ linked(Malloc_0).
  (* Goal *)
  When: (0 <= i) /\ (i <= 2) /\
      (!invalid(Malloc_0, shift_S2_With_array(s, 0), 12)).
}
Prove: i = 2.

------------------------------------------------------------
------------------------------------------------------------
  Function RANGE_NESTED_ARRAY_VARS
------------------------------------------------------------

Goal Termination-condition (generated) in 'RANGE_NESTED_ARRAY_VARS':
Prove: true.

------------------------------------------------------------

Goal Exit-condition (generated) in 'RANGE_NESTED_ARRAY_VARS':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 121) in 'RANGE_NESTED_ARRAY_VARS':
Call Effect at line 126
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 121) in 'RANGE_NESTED_ARRAY_VARS':
Call Effect at line 126
Let a = shift_S2_With_array(s, 0).
Let x = 4 * n.
Let x_1 = 4 + x.
Let a_1 = shift_S2_With_array(s, 2).
Let x_2 = x - 4.
Let a_2 = shift_S2_With_array(s, i).
Let a_3 = shift_S2_With_array(s, 1).
Let a_4 = shiftfield_F2_With_array_t(a).
Let a_5 = shift_sint32(a_4, 1).
Let a_6 = shift_sint32(shiftfield_F2_With_array_t(a_3), 0).
Let x_3 = 1 + m.
Assume {
  Type: is_uint32(m) /\ is_uint32(n).
  (* Heap *)
  Type: (region(s.base) <= 0) /\ linked(Malloc_0).
  (* Goal *)
  When: (0 <= i) /\ (i <= n) /\ (!invalid(Malloc_0, a, x_1)).
  (* Pre-condition *)
  Have: (3 <= n) /\ (4 <= m).
}
Prove: (n < 0) \/ included(a, x_1, a_1, x_2) \/ included(a_2, 4, a_1, x_2) \/
    included(a, x_1, shiftfield_F2_With_array_x(a_3), 1) \/
    included(a, x_1, shift_sint32(a_4, 0), 1) \/ included(a, x_1, a_5, m) \/
    included(a, x_1, a_6, x_3) \/ included(a_2, 4, a_5, m) \/
    included(a_2, 4, a_6, x_3).

------------------------------------------------------------
------------------------------------------------------------
  Function USE_ASSIGN_UNFOLD_KO
------------------------------------------------------------

Goal Termination-condition (generated) in 'USE_ASSIGN_UNFOLD_KO':
Prove: true.

------------------------------------------------------------

Goal Post-condition (file unfold_assigns.i, line 52) in 'USE_ASSIGN_UNFOLD_KO':
Let a = Load_S1_S(q, Mint_0).
Let a_1 = Load_S1_S(q, memcpy(Mint_0, Mint_undef_0, p, p, 2)).
Assume {
  Type: IsS1_S(a) /\ IsS1_S(a_1).
  (* Heap *)
  Type: (region(p.base) <= 0) /\ (region(q.base) <= 0).
  (* Goal *)
  When: separated(p, 2, q, 2).
}
Prove: EqS1_S(a_1, a).

------------------------------------------------------------

Goal Exit-condition (generated) in 'USE_ASSIGN_UNFOLD_KO':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 53) in 'USE_ASSIGN_UNFOLD_KO':
Call Effect at line 57
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 53) in 'USE_ASSIGN_UNFOLD_KO':
Call Effect at line 57
Prove: true.

------------------------------------------------------------
------------------------------------------------------------
  Function USE_ASSIGN_UNFOLD_OK
------------------------------------------------------------

Goal Termination-condition (generated) in 'USE_ASSIGN_UNFOLD_OK':
Prove: true.

------------------------------------------------------------

Goal Post-condition (file unfold_assigns.i, line 43) in 'USE_ASSIGN_UNFOLD_OK':
Let a = Load_S1_S(q, Mint_0).
Let a_1 = Load_S1_S(q, memcpy(Mint_0, Mint_undef_0, p, p, 2)).
Assume {
  Type: IsS1_S(a) /\ IsS1_S(a_1).
  (* Heap *)
  Type: (region(p.base) <= 0) /\ (region(q.base) <= 0).
  (* Goal *)
  When: separated(p, 2, q, 2).
}
Prove: EqS1_S(a_1, a).

------------------------------------------------------------

Goal Exit-condition (generated) in 'USE_ASSIGN_UNFOLD_OK':
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 44) in 'USE_ASSIGN_UNFOLD_OK':
Call Effect at line 48
Prove: true.

------------------------------------------------------------

Goal Assigns (file unfold_assigns.i, line 44) in 'USE_ASSIGN_UNFOLD_OK':
Call Effect at line 48
Prove: true.

------------------------------------------------------------
