[kernel] Parsing multiple_file_1.c (with preprocessing)
[kernel] Parsing multiple_file_2.c (with preprocessing)
[kernel:typing:int-conversion] multiple_file_2.c:28: Warning: 
  Array type comparison succeeds only based on machine-dependent constant evaluation: int [sizeof(struct i_s2)] and int [sizeof(struct i_s2)]
[kernel:typing:merge-conversion] multiple_file_2.c:28: Warning: 
  Conflicting definitions for types 'int [sizeof(struct i_s2)]' and 'int [sizeof(struct i_s2)]' (previous definition was in file multiple_file_1.c).
[kernel:typing:int-conversion] multiple_file_2.c:36: Warning: 
  Array type comparison succeeds only based on machine-dependent constant evaluation: int [sizeof(void *)] and int [sizeof(struct i_s2)]
[kernel:typing:int-conversion] multiple_file_2.c:38: Warning: 
  Array type comparison succeeds only based on machine-dependent constant evaluation: int [sizeof(struct i_s2)] and int [sizeof(void *)]
[kernel:linker:drop-conflicting-unused] Warning: 
  Incompatible declaration for t2:
  different array lengths
  First declaration was at multiple_file_1.c:14
  Current declaration is at multiple_file_2.c:66
  Current declaration is unused, silently removing it
[kernel:typing:int-conversion] multiple_file_2.c:67: Warning: 
  Array type comparison succeeds only based on machine-dependent constant evaluation: int [sizeof(long long)] and int [sizeof(long)]
[kernel] multiple_file_1.c:10: Warning: found two contracts. Merging them
/* Generated by Frama-C */
struct i_s2 {
   float i2 ;
   int i1 ;
};
struct typ2 {
   int tab[sizeof(struct i_s2)] ;
};
struct typ4 {
   int tab[sizeof(void *)] ;
};
struct typ5 {
   int tab[sizeof(unsigned char *)] ;
};
union typ6 {
   int tab[sizeof(long)] ;
};
enum EN {
    AB = 0,
    AC = 1,
    AD = 2
};
/*@ requires x ≥ 0; */
extern int f(int x);

/*@ requires x ≥ 0;
    requires x ≤ 0; */
extern int g(int x);

extern int t1[sizeof(long)];

extern int t2[sizeof(int)];

extern int t3[sizeof(long long)];

struct typ2 h;
struct typ2 l;
struct typ4 m;
struct typ5 n;
union typ6 o;
int t = (int)sizeof(h.tab);
int (*p)(int , int );
int v1_ok = (int)sizeof(p);
int (*p1)(int );
int v1_ok_2 = (int)sizeof(p1);
int f1(int, int);

int v2 = (int)sizeof(f1);
int f2(int);

int v2_ok_2 = (int)sizeof(f2);
int v3 = (int)sizeof(enum EN);
int main(void)
{
  int tmp;
  g(0);
  t1[0] = 0;
  t2[0] = 0;
  t3[0] = 0;
  tmp = f(0);
  return tmp;
}


